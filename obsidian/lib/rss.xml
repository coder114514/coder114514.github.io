<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>blog</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 17 Jun 2024 08:55:23 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 17 Jun 2024 08:55:02 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[0000-00-00-目录]]></title><description><![CDATA[ 
 <br>]]></description><link>blog\0000-00-00-目录.html</link><guid isPermaLink="false">blog/0000-00-00-目录.md</guid><pubDate>Fri, 17 Nov 2023 13:21:07 GMT</pubDate></item><item><title><![CDATA[2022-11-22-线段树处理负数端点值]]></title><description><![CDATA[ 
 <br>如果线段树端点值可以取负数，那么用计算中点（向0取整，即c++的整除）<br>也就是，如果  能平分就平分，否则左区间比右区间长度小1<br>如果  能平分就平分，否则左区间比右区间长度多1<br>e.g.<br>比如 , <br>
<br> 正常
<br> 死循环
]]></description><link>blog\2022-11-22-线段树处理负数端点值.html</link><guid isPermaLink="false">blog/2022-11-22-线段树处理负数端点值.md</guid><pubDate>Thu, 17 Aug 2023 03:57:26 GMT</pubDate></item><item><title><![CDATA[2022-11-22-整数数据范围和memset初值]]></title><description><![CDATA[ 
 <br><br><br><br><br>
<br>正无穷：0x3f, 0x7f
<br>负无穷：0xc0, 0x80, 0xbf
<br>两倍不会溢出的：0x3f, 0xc0
]]></description><link>blog\2022-11-22-整数数据范围和memset初值.html</link><guid isPermaLink="false">blog/2022-11-22-整数数据范围和memset初值.md</guid><pubDate>Thu, 17 Aug 2023 03:57:30 GMT</pubDate></item><item><title><![CDATA[2022-11-22-Dijkstra最短路算法]]></title><description><![CDATA[ 
 <br><br>假设我们用数据结构  维护每个点的 <br>
<br>初始化  并加入 , 其余点的  设为无限大, 所有点标记为未访问
<br>重复3-5，直到没有未访问的点，算法结束
<br>从  中选出  最小且未访问的点，记为 （中查询）
<br>把  标记为已访问并把它从  中删除（中删除）
<br>对  所有出边进行松弛操作（中修改和插入）
<br><br>单源多汇最短路，无负权边<br><br>已经访问的点是已经确定了最短路的点，未访问的点是有待确认的点<br>对于一个未访问的点中  最小的点，它的  首先已经被已经访问过的点松弛过了，所以能让它  更小的未访问的点不存在<br>而其他的点的  都不比它小，且边权非负，也不能让  更小，所以这个点的最短路确定就是  了<br><br><br>操作3的总复杂度为 <br>操作5的总复杂度为 <br>复杂度 <br><br>操作3总复杂度为 <br>操作4总复杂度为 <br>操作5总复杂度为 <br>复杂度 <br><br>类似于堆，但是没有修改和删除操作，所以队内元素有  个<br>操作3总复杂度为 <br>操作5总复杂度为 <br>复杂度 <br>不过 ，因为  最多是  的<br><br>稀疏图中，，优先队列复杂度比暴力更优<br>稠密图中，，暴力复杂度反而更优<br><br>typedef pair&lt;int, int&gt; pii;

int dis[NV], S;
bool vis[NV];

void Dijkstra() {
    memset(vis, 0, sizeof(vis));
    memset(dis, 0x3f, sizeof(dis));
    dis[S] = 0;
    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;
    q.push(make_pair(0, S));
    while (!q.empty()) {
        int u = q.top().second;
        q.pop();
        if (vis[u]) continue;
        vis[u] = true;
        for (int i = hd[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            int c = e[i].c;
            if (dis[v] &gt; dis[u] + c) {
                dis[v] = dis[u] + c;
                q.push(make_pair(dis[v], v));
            }
        }
    }
}

void Dijkstra_BF() {
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    dis[S] = 0;
    // 每次循环能标记一个点
    for (int iV = 1; iV &lt; n; iV++) {
        int min_dis = INF;
        int u;
        for (int i = 1; i &lt;= n; i++) {
            if (!vis[i] &amp;&amp; dis[i] &lt; min_dis) {
                min_dis = dis[i];
                u = i;
            }
        }
        vis[u] = true;
        for (int i = hd[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            int c = e[i].c;
            if (dis[v] &gt; dis[u] + c) {
                dis[v] = dis[u] + c;
            }
        }
    }
}
Copy]]></description><link>blog\2022-11-22-dijkstra最短路算法.html</link><guid isPermaLink="false">blog/2022-11-22-Dijkstra最短路算法.md</guid><pubDate>Thu, 17 Aug 2023 03:57:39 GMT</pubDate></item><item><title><![CDATA[2022-11-22-Floyd和倍增Floyd]]></title><description><![CDATA[ 
 <br><br>能解决没有负环的图上的多源多汇的最短/最长路问题<br>修改之后能用来计算连通性（传递闭包），找无向图最小环和检测负环<br>令  表示从  号结点到  号结点只经过  ,  和  到  号结点的最短路径<br>初始状态<br><br>转移方程<br>
<br>可以证明第一维是可以被滚动优化掉的<br>代码：<br>// 关于k的循环必须在最外层（因为第一维被滚动掉了）
for (int k = 1; k &lt;= n; k++) {
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= n; j++) {
            f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
        }
    }
}
Copy<br>显然最长路就是把 min 变成 max<br><br>用来解决限定步数的最短/最长路问题<br>定义矩阵运算：<br>单位元是除了对角线上是  其余位置都是  的矩阵<br>可以证明这个运算是满足结合律的<br>令  表示  (因为满足结合律所以无论怎么加括号结果都是一样的)<br>若  是邻接矩阵，则  表示从结点  到结点  恰好 走  步的最短路径<br>可以用快速幂计算 <br>最长路就是把 min 变成 max，单位元变成除了对角线上是  其余位置都是  的矩阵<br>代码：<br>// f[p][i][j]表示从i到j恰好走2^p步的最短路
// 初值：f[0][i][j]=infinity, 如果(i,j)没有边，否则f[0][i][j]=w(i,j)
for (int p = 1; (1 &lt;&lt; p) &lt;= nStep; p++) {
    // 里面三层循环可以任意交换顺序
    for (int k = 1; k &lt;= nV; k++) {
        for (int i = 1; i &lt;= nV; i++) {
            for (int j = 1; j &lt;= nV; j++){
                f[p][i][j] = min(f[p][i][j], f[p-1][i][k] + f[p-1][k][j]);
            }
        }
    }
}

// 计算走恰好nStep的最短路，结果存在G数组里面
memset(G, 0x3f, sizeof(G));
for (int i = 1; i &lt;= nV; i++) {
    G[i][i]=0;
}

for (int p = 0; (1&lt;&lt;p) &lt;= nStep; p++) { // 和快速幂一样
    if (((1&lt;&lt;p) &amp; nStep) == 0) {
        continue;
    }
    memset(F, 0x3f, sizeof(F));
    for (int k = 1; k &lt;= nV; k++) {
        for (int i = 1; i &lt;= nV; i++) {
            for (int j = 1; j &lt;= nV; j++) {
                F[i][j] = min(F[i][j], G[i][k] + f[p][k][j]);
            }
        }
    }
    memcpy(G, F, sizeof(F));
}
Copy]]></description><link>blog\2022-11-22-floyd和倍增floyd.html</link><guid isPermaLink="false">blog/2022-11-22-Floyd和倍增Floyd.md</guid><pubDate>Sat, 02 Dec 2023 15:06:30 GMT</pubDate></item><item><title><![CDATA[2022-12-06-NOIP2022游寄]]></title><description><![CDATA[ 
 <br><br>简单题，但是我错误得估计了复杂度  不够过1000，其实我只要再做个前缀和应该就能100了<br><br>考场上没思路，事后发现$ k=2n-2 $ 还是很好想的<br><br>写了个Tarjan缩点和链的情况，预计拿20，但是20炸了，树上dp也没想出来<br><br>不会写，写个暴力然后就不管了<br><br>大寄特寄，明年高三的时候希望能考好一点吧]]></description><link>blog\2022-12-06-noip2022游寄.html</link><guid isPermaLink="false">blog/2022-12-06-NOIP2022游寄.md</guid><pubDate>Thu, 17 Aug 2023 03:57:46 GMT</pubDate></item><item><title><![CDATA[2022-12-15-洛谷P1654-OSU]]></title><description><![CDATA[ 
 <br><br>令  表示  的分数（随机变量）， 表示从  往前的连续的长度（随机变量）， 表示第  位是否命中， 表示第  位命中的概率<br><br><br><br><br><br>因为与无关，所以可以直接把之前的替换为<br>]]></description><link>blog\2022-12-15-洛谷p1654-osu.html</link><guid isPermaLink="false">blog/2022-12-15-洛谷P1654-OSU.md</guid><pubDate>Thu, 17 Aug 2023 03:57:49 GMT</pubDate></item><item><title><![CDATA[2022-12-20-OSU拓展]]></title><description><![CDATA[ 
 <br><br>B 君并不喜欢 OSU，但是 B 君觉得 OSU 这个题不错。<br>输入  和 ，一共有  次点击，每次可以可能成功或失败。<br>对于一段长度为  连续极长的成功点击序列，得分是 。<br>已知第  次点击的成功率是 。<br>问期望得分是多少？<br>因为得分可能很大，并且不是整数，只需要输出得分模 1000000007 的结果即可。<br><br>对算法正确性的说明：<a data-href="2023-01-17-再看OSU拓展" href="\blog\2023-01-17-再看osu拓展.html" class="internal-link" target="_self" rel="noopener">2023-01-17-再看OSU拓展</a><br>#include &lt;bits/stdc++.h&gt;
using namespace std;
int n, m, mod = 1000000007;
long long p[100020];
long long a[1020];
long long b[1020];
long long s[1020][120];
long long f[1020];
int main() {
	scanf("%d%d", &amp;n, &amp;m);
	s[0][0] = 1;
	for (int i = 0; i &lt;= m; i++) {
		for (int j = 1; j &lt;= i; j++) {
			s[i][j] = (s[i - 1][j - 1] + j * s[i - 1][j]) % mod;
		}
	}
	for (int i = f[0] = 1; i &lt;= m; i++) {
		f[i] = f[i - 1] * i % mod;
	}
	for (int i = 1; i &lt;= n; i++) {
		scanf("%lld", &amp;p[i]);
		p[i] = p[i] * 570000004 % mod;
		for (int j = m; j &gt; 0; j--) {
			a[j] += a[j - 1];
			a[j] *= p[i];
			a[j] %= mod;
			b[j] += a[j];
			b[j] %= mod;
		}
		a[0] = p[i];
		b[0] += a[0];
		b[0] %= mod;
	}
	long long z = 0;
	for (int i = 1; i &lt;= m; i++) {
		z = (z + b[i - 1] * f[i] % mod * s[m][i]) % mod;
	}
	printf("%lld\n", z);
	return 0;
}
Copy]]></description><link>blog\2022-12-20-osu拓展.html</link><guid isPermaLink="false">blog/2022-12-20-OSU拓展.md</guid><pubDate>Thu, 17 Aug 2023 03:58:55 GMT</pubDate></item><item><title><![CDATA[2023-01-08-欧拉法的误差分析]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://math.stackexchange.com/questions/3109359/global-error-in-eulers-method" rel="noopener" class="external-link" href="https://math.stackexchange.com/questions/3109359/global-error-in-eulers-method" target="_blank">出处</a><br>要解的微分方程： ，而  是已知的<br>欧拉法(Euler's method):<br><br>其中 <br>要满足的条件：<br>
<br>存在常数  满足: 对于所有的  , 
<br>存在常数  满足: 对于所有的  , 
<br>令  表示  时的累积误差<br> , 其中 <br>那么<br><br>所以<br><br>所以累积误差是  的<br>不过在实际情况中，这个式子经常过高估计欧拉法的误差]]></description><link>blog\2023-01-08-欧拉法的误差分析.html</link><guid isPermaLink="false">blog/2023-01-08-欧拉法的误差分析.md</guid><pubDate>Thu, 17 Aug 2023 03:57:52 GMT</pubDate></item><item><title><![CDATA[2023-01-08-树状数组BIT正确性的证明]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://codeforces.com/blog/entry/77089" rel="noopener" class="external-link" href="https://codeforces.com/blog/entry/77089" target="_blank">出处1</a><br>
<a data-tooltip-position="top" aria-label="https://oi-wiki.org/ds/fenwick/#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%85%B6%E6%A0%91%E5%BD%A2%E6%80%81%E7%9A%84%E6%80%A7%E8%B4%A8" rel="noopener" class="external-link" href="https://oi-wiki.org/ds/fenwick/#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%85%B6%E6%A0%91%E5%BD%A2%E6%80%81%E7%9A%84%E6%80%A7%E8%B4%A8" target="_blank">出处2</a><br>假设树状数组是 ， 表示  到  这个区间的和<br><br>根据定义， 已经包含  到  这个区间了，所以在的时候不断  就可以求所要的前缀和了<br>而对于显然有 ，于是这个过程一定可以终止<br><br>比如修改 ，显然  需要更新，接下来证明要更新的是 ， 之类的<br>分两步<br><br>设（显然任意整数都能写成这个形式），则，<br>不难发现 ，其中  ，由此得出<br><br><br>设，则，其中<br>不难发现 <br>从而  即  不包含 <br>所以在时不断 ，显然这个过程也一定会终止]]></description><link>blog\2023-01-08-树状数组bit正确性的证明.html</link><guid isPermaLink="false">blog/2023-01-08-树状数组BIT正确性的证明.md</guid><pubDate>Thu, 17 Aug 2023 03:57:55 GMT</pubDate></item><item><title><![CDATA[2023-01-17-再看OSU拓展]]></title><description><![CDATA[ 
 <br>书接上文：<a data-href="2022-12-20-OSU拓展" href="\blog\2022-12-20-osu拓展.html" class="internal-link" target="_self" rel="noopener">2022-12-20-OSU拓展</a><br>我终于想明白算法的正确性了<br><br><br><br><br>对比  和 <br>它们的组合意义相同：把  个不同球放进  个不同的盒子中，第一个盒子和最后一个盒子非空，中间的盒子可以是空盒的时候的方案数，由此可以看出正解的正确性。<br>不过它是怎么推导出来的我还没有想通]]></description><link>blog\2023-01-17-再看osu拓展.html</link><guid isPermaLink="false">blog/2023-01-17-再看OSU拓展.md</guid><pubDate>Thu, 17 Aug 2023 03:58:58 GMT</pubDate></item><item><title><![CDATA[2023-02-05-latex和markdown冲突]]></title><description><![CDATA[ 
 <br>Jekyll有时候会把latex公式里的一些符号当成markdown的符号处理掉，然后mathjax就不能正常渲染数学公式了，需要在一些地方用反斜杠escape掉那些字符才行，但是这么做这些latex就不能在其他地方正常渲染了...<br>用 Obsidian 之后就好很多]]></description><link>blog\2023-02-05-latex和markdown冲突.html</link><guid isPermaLink="false">blog/2023-02-05-latex和markdown冲突.md</guid><pubDate>Thu, 17 Aug 2023 03:58:23 GMT</pubDate></item><item><title><![CDATA[2023-02-08-网络流入门]]></title><description><![CDATA[ 
 <br>注：本文只考虑整数容量、整数流，但一部分论证可以直接推广到非整数流的问题上<br><br>首先，网络（flow network）是指一个有向图 ，其中有两个特殊点: 源点（source） 和汇点（sink）（）<br><br>容量  是一个  的映射, 规定：<br>如果  那么 <br>否则 <br><img alt="cap.png" src="\lib\media\cap.png"><br><br><img alt="flow.png" src="\lib\media\flow.png"><br>流量  也是的映射<br>它要满足如下三个性质：<br>
<br>容量限制：
<br>斜对称性（skew symmetry）：
<br>流守恒性：流入一个点的流量等于流出这个点的流量 
<br>注意到由1和2:<br>
<br>
<br>
<br>流的大小定义为 <br>为了便于讨论，定义符号 <br>那么有:<br>
<br>
<br> 第二个参数也是同理
<br>
<br>由此可以推出 <br><br>形式化地，，其中 ，其中  即剩余流量（residual capacity）<br><img alt="res.png" src="\lib\media\res.png"><br><br>最大流就是大小最大的流<br>增广路径就是残量网络上从源点到汇点的一条路径<br><img alt="aug.png" src="\lib\media\aug.png"><br>不停地找增广路径（然后在残量图上修改相应的流量）直到没有任何增广路径，我们就可以得到最大流 - 这就是增广路定理（之后会论证这个定理）<br>实际上流的斜对称性就是用来“退流”的，比如我们之前选的流不够好，它就能撤销掉之前的流<br><br><br>复杂度:  其中是最大流<br>是最简单的最大流算法，但是复杂度很差，在有些图上运行时间会和容量成正比<br>Ford-Fulkerson Killer（如果每次dfs运气不好都过中间那条边的话，算法就要找200次增广路了）<br>
<img alt="ffkill.png" src="\lib\media\ffkill.png"><br><br>找到的增广路径叫做最短步数增广路(SAP, Shortest Augmenting Path)<br>复杂度： <a data-tooltip-position="top" aria-label="https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="noopener" class="external-link" href="https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" target="_blank">证明</a><br>实际效果: 1秒可以处理上万个节点的稀疏图，通常运行速度达不到这个上界这么慢<br><br>int pre[NV], flow[NV];

bool bfs() {
    queue&lt;int&gt; q;
    memset(pre, 0, sizeof(pre));
    pre[S] = -1;
    flow[S] = INF;
    q.push(S);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = hd[u]; i; i = e[i].nxt) {
            int c = e[i].c;
            if (!c) continue;
            int v = e[i].to;
            if (pre[v]) continue;
            q.push(v);
            pre[v] = i;
            flow[v] = min(flow[u],c);
            if (v == T) return true;
        }
    }
    return false;
}

int EK() {
    int maxFlow = 0;
    while (bfs()) {
        maxFlow += flow[T];
        for(int u = T; u; u = e[pre[u]^1].to){
            e[pre[u]].c -= flow[T];
            e[pre[u]^1].c += flow[T];
        }
    }
    return maxFlow;
}
Copy<br><br>复杂度： <a data-tooltip-position="top" aria-label="https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90_1" rel="noopener" class="external-link" href="https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90_1" target="_blank">证明</a><br>实际效果: 1秒可以处理上万个节点的稀疏图，复杂度往往达不到这个上界，所以不能通过将,代入来估计算法复杂度<br>使用bfs分层+dfs多路探索以及当前弧加速（current-arc acceleration）<br>注意：当前弧加速是必须要有的，它是用于保证时间复杂度正确性的一部分，而多路探索是常数优化<br>设为从源点bfs到u的轮数+1，然后根据对残量图进行分层得到层次图<br>形式化地，定义为的层次图，<br><img alt="lvl.png" src="\lib\media\lvl.png"><br>
(黑边残量图，红边层次图)<br>每轮bfs求出后在它上面dfs多路探索得到它上最大的流，然后修改残量图并给答案加上这个流<br>dfs多路探索的时候我们要应用当前弧加速，当前弧加速就是说，因为我们可以提前知道哪些路径走下去肯定到不了终点，我们就可以提前决定不去走它们<br>int S, T;
int lv[N];
int cur[N]; //这个就是当前弧加速

bool bfs() {
    memset(lv, 0, sizeof(lv));
    queue&lt;int&gt; q;
    q.push(S);
    lv[S] = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = hd[u]; i; i = e[i].nxt) {
            int c = e[i].c;
            if (!c) continue;
            int v = e[i].to;
            if (lv[v]) continue;
            q.push(v);
            lv[v] = lv[u] + 1;
        }
    }
    return lv[T];
}

int dfs(int u, int f) {
    if (u == T) return f;
    int sum = 0;
    for (int i = cur[u]; i &amp;&amp; f; i = e[i].nxt) {
        cur[u] = i; //这条边所有的流量已经被用掉了，后面再来这个结点的时候不需要再走这条边了
        int v = e[i].to;
        int c = e[i].c;
        if (lv[v] != lv[u] + 1 || !c) continue; //这条边其实不在层次图里面
        int delta = dfs(v, min(f, c)); //这是多路探索，就是不需要每次都从源点开始找增广路径
        sum += delta;
        f -= delta;
        e[i].c -= delta;
        e[i ^ 1].c += delta;
    }
    return sum;
}

int Dinic() {
    int maxFlow = 0;
    while (bfs()) {
        for (int i = 1; i &lt;= n; i++) cur[i] = hd[i]; //每次dfs前要重置这个
        maxFlow += dfs(S, INF);
    }
    return maxFlow;
}
Copy<br><br>一个割就是满足的对的划分<br>割的大小定义为 ，最小割定义为大小最小的割<br>最小割另一个等价的定义是最小的通过删边使源点到汇点不再连通的删去的边的权值和（等价是因为最小割肯定是分为可达点和不可达点的割）<br>引理：对于任意的割和流，<br>证明：<br><br>即最大流等于最小割<br>证明：由上面的引理容易得到对任意的流和割，<br>那么如果存在一个流和一个割满足  就可以证明该定理（若这个  不是最大流，显然会产生矛盾）<br>假设我们根据之前的 Ford-Fulkerson 算法找到了一个流（当然还不知道是最大流），那残量网络中肯定没有从到的路径（算法终止条件），于是我们可以把点划分为可达的和不可达的，得到一个割 。<br>对于所有满足的点对，由于残量图中可以达到，但不能达到，所以，然而，所以<br>由引理可得，<br>Q.E.D<br><br><br>比如对于这个二分图<br><img alt="bin.png" src="\lib\media\bin.png"><br>这么建图，然后再上面跑一遍最大流就可以得到最大匹配了（下图中每条边的边权都是1，反向边省略）<br><img alt="binflow.png" src="\lib\media\binflow.png"><br><br>比如有个物品要放入集合或集合，第个不放要消耗，不放要消耗，和不在一起要消耗，求最小消耗<br>那我们可以先建立一个超级源和超级汇，超级源到的边权为，到超级汇的边权为，和连权值为的双向边，在这张图上跑最小割，就可以得到最小消耗<br>可以用表示和必须放在一起<br><br><br>幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。<br>对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。<br>虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。<br>我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。<br>我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？<br><br>这个问题很符合上面“二选一”的模型<br>我们可以从超级源向每个要睡觉的小朋友连一条权值为1的边，从超级汇向每个不要睡觉的小朋友连一条权值为1的边，好朋友之间连一条权值为1的双向边，再跑最小割就能得到答案了。<br><br>在一个n*n的方格里，每个格子里都有一个正整数。<br>从中取出若干数，使得任意两个取出的数所在格子没有公共边，且取出的数的总和尽量大。<br>输入：<br>第一行是n，接下来n行是n*n方阵<br><br>因为最大总和等于所有数的和减掉最小的不选的总和<br>所以我们考虑如何用最小割建模最小的不选的总和<br>首先把格子按行号与列号的和的奇偶性分类<br><img alt="board.png" src="\lib\media\board.png"><br>从源点向偶格子连边，权值为格子中的值；从奇格子向汇点连边，权值为格子中的值；从偶格子向它周围的四个奇格子连边，权值为<br><img alt="boardnet.png" src="\lib\media\boardnet.png"><br><br>考虑一个割<br>对于一个奇格子，在里是选它，在里是不选它；对于偶格子，在里是不选，在里是选。<br>如果一个奇格子是，它连着的偶格子都是，就代表不选偶格子（偶格子不能是，因为奇格子都偶格子连了个无限大的边，如果是那这个割就不可能是最小割了）<br>奇格子是，偶格子也是，就代表不选奇格子<br>奇格子是，偶格子是，就代表都不选<br>求出最小割，就是最小的不选的总和了<br><br>首先无限大的边肯定不能割，而如果我割左边一条边（图中橙边），那么就表示我不要奇格子，然后右边连接着的偶格子就有保留的机会了<br>而如果我不割左边割右边（图中蓝边），那么我就必须把相应的4个（或2个3个）全部割掉才能使图不连通，如果我这时候突然又决定把左边割掉，那么其实是不划算的（割左边的话就没必要割右边了，因为我们要最小割，而割左边是前面一个情况）<br>由此可见这是保证了不能选相邻格子的限制的<br><br><img src="https://camo.githubusercontent.com/caee0028ca51211c7c1f2091a3895ea7fde72375c7fbdd32b256fd5d53036e89/68747470733a2f2f636f6465723131343531342e6769746875622e696f2f696d616765732f666c6f772f6c766c332e706e67" referrerpolicy="no-referrer"><br>
ab这条边为 “不在同一阵营的惩罚”<br>
<img src="https://camo.githubusercontent.com/7110bd04c1ed02fe816b95d85738971ffe48bbe02a2fa2ecf9ead85d5f37b57f/68747470733a2f2f636f6465723131343531342e6769746875622e696f2f696d616765732f666c6f772f6c766c352d312e706e67" referrerpolicy="no-referrer"><br>
<img src="https://camo.githubusercontent.com/156394e796e7305b3e6eb2146262a0ef2f442f5de7246280c201fd77ae96d1f0/68747470733a2f2f636f6465723131343531342e6769746875622e696f2f696d616765732f666c6f772f6c766c352d322e706e67" referrerpolicy="no-referrer"><br>
Sc和dT两条边可看作 “同阵营奖励”]]></description><link>blog\2023-02-08-网络流入门.html</link><guid isPermaLink="false">blog/2023-02-08-网络流入门.md</guid><pubDate>Thu, 17 Aug 2023 03:58:05 GMT</pubDate><enclosure url="lib\media\cap.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\cap.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2023-02-10-Konig定理和匈牙利算法(其实是增广路算法)]]></title><description><![CDATA[ 
 <br><br>点覆盖：节点的集合，满足每条边至少有一个端点被选<br>最小点覆盖: 点数最少的点覆盖<br>Konig定理: 在一个二分图中，最大匹配数等于最小点覆盖<br><br>首先，因为匹配边没有共同的端点，而一个点覆盖中每条边至少有一个端点被选，所以所有点覆盖大于等于最大匹配<br>接下来我们只要能构造出一个等于最大匹配数的点覆盖就可以证明Konig定理<br>在最大匹配中，一条边有四种情况：<br>
<br>匹配边
<br>非匹配边，两端点都参与匹配
<br>非匹配边，只有左端点参与匹配
<br>非匹配边，只有右端点参与匹配
<br>接下来我们这么构造点覆盖：<br>
<br>对于只有左端参与匹配的非匹配边，选取它的左端点
<br>把端点被选中的边去掉，重复步骤1
<br>对于剩下的匹配边选它们的右端点
<br>首先，选的点都是匹配边的端点，所以选出来了最大匹配数个点，也是因为这个，所有匹配边肯定被覆盖。接下来考虑所有非匹配边，重复过步骤1之后，所有第三种边都被覆盖；在最后一步之后，就能把第二种和第四种覆盖。于是所有边都被覆盖了，选出来的点确实组成点覆盖。<br>Q.E.D<br><br>交错路(alternating path)：由匹配边与非匹配边交错而成 (只有一条边也可以)<br>增广路(augmenting path): 起点和终点都不参与匹配的交错路<br>枚举起点，不停找增广路<br><img alt="/image/konig/aug.png" src="\lib\media\aug.png"><br>找到之后反转一下（匹配边变非匹配边，反之亦然）就能使匹配数增加一<br><img alt="inv.png" src="\lib\media\inv.png"><br>没有增广路之后就得到了最大匹配<br>注意到这个过程中原先的匹配点不会变成非匹配点，只可能会新增匹配点<br>枚举起点时，每个非匹配点只需要被枚举一次，如果以它为起点存在增广路，那增广后它就不能再作为起点，因为它变成匹配点了，而如果不存在增广路，也就是找不到终点是非匹配点的交错路，那之后也不可能再找到增广路，因为不会新增非匹配点。<br>在此基础上，我们只需要枚举左侧点，假设左侧点都被增广过之后，右侧点还有未匹配的，那么以它们为起点不可能有增广路，因为以它们为起点的增广路的终点一定在左侧点中（因为增广路长度肯定是奇数）但是这与所有左侧点已经被增广过矛盾（增广的时候就应该找到这条增广路了）<br>综上，我们只需要枚举每个左侧点1次<br><br>//假设左边的点编号为[1,nL]
bool vst[NV]; //表示右侧的点在这轮寻找增广路的时候有没有被访问过
int match[NV]; //表示右侧的点匹配上了左侧的哪个点

//返回值代表有没有找到增广路
bool find(int u) {
    for (int i = hd[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (vst[v]) continue;
        vst[v] = true;
        if (!match[v] || find(match[v])) {
            match[v] = u;
            return true;
        }
    }
    return false;
}

int Hungarian() {
    int maxMatch = 0;
    for (int u = 1; u &lt;= nL; u++) {
        memset(vst, 0, sizeof(vst));
        maxMatch += find(u);
    }
    return maxMatch;
}
Copy<br><br>一个匹配是最大匹配当且仅当这个二分图中不存在增广路。这个定理保证了上述算法的正确性。<br>正方向是很显然的，接下来证明反方向。<br>条件是当前的匹配M下二分图不存在增广路。使用反证法，假设匹配M'比匹配M更大（M'和M是匹配边的集合）<br>令D为M与M'的对称差，那么D中的边要么能组成长度为偶数的回路，要么就是在M与M'间交替的路径，因为D中每个节点最多能连接两条边（一条M的,一条M'的），而形成回路的路径中在M中的边的数量与在M'中的边的数量是相等的，于是回路一定是偶数长度的。<br>因为M'比M更大，所以D中一定存在某个极大的分量其中在M'中的边的数量比在M中的边的数量多，这样的一条路径一定是以M'中的边开始，M'中的边结束的极大的路径，注意到这个路径中在M'中的边是不在M中的（对称差定义），而且对于它的起点和终点，它们在M中一定是未匹配点，否则要么路径不是极大的，要么M'就是个不合法的匹配。<br>综上，这就意味着存在一条增广路，但是这与条件不存在增广路矛盾。<br>Q.E.D]]></description><link>blog\2023-02-10-konig定理和匈牙利算法(其实是增广路算法).html</link><guid isPermaLink="false">blog/2023-02-10-Konig定理和匈牙利算法(其实是增广路算法).md</guid><pubDate>Thu, 17 Aug 2023 03:57:58 GMT</pubDate><enclosure url="lib\media\aug.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\aug.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2023-02-18-变质量系统中力与动量的关系]]></title><description><![CDATA[ 
 <br>由牛顿第二定律可以得出不变时 <br>那么在会变时还是这样的吗？<br>实际上会变时方程是这样的：<br>其中是指时刻时，增加的质量速度从变成，或者减少的质量速度从变成<br><br>在到的时候，<br>再将除到右边即可得到上述方程<br><br>一个真空中的火箭以相对自身的速度向反方向喷射气体，那么我们可以得到如下方程<br><br><br><br><br><br>]]></description><link>blog\2023-02-18-变质量系统中力与动量的关系.html</link><guid isPermaLink="false">blog/2023-02-18-变质量系统中力与动量的关系.md</guid><pubDate>Thu, 17 Aug 2023 03:58:01 GMT</pubDate></item><item><title><![CDATA[2023-02-20-云图床炸了]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://cloudimge.com/" rel="noopener" class="external-link" href="https://cloudimge.com/" target="_blank">云图床</a>好像在进行维护工作，虽然上面说“请过几分钟回来”，但是它已经维护了好几天了...<br>我目前博客里大部分图片都上传在它上面，希望它赶快搞好吧。<br>所以这段时间很多图片都不会显示。<br>2023/3/19更新：原来是被攻击了，似乎现在开始恢复了<br>现在彻底寄了]]></description><link>blog\2023-02-20-云图床炸了.html</link><guid isPermaLink="false">blog/2023-02-20-云图床炸了.md</guid><pubDate>Thu, 17 Aug 2023 03:59:01 GMT</pubDate></item><item><title><![CDATA[2023-02-23-毒瘤题,纪念一下]]></title><description><![CDATA[ 
 <br>题目: <a rel="noopener" class="external-link" href="https://www.luogu.com.cn/problem/P5046" target="_blank">https://www.luogu.com.cn/problem/P5046</a><br>提交次数多达两页半<br><a data-tooltip-position="top" aria-label="https://github.com/coder114514/OI_code/blob/main/www.luogu.com.cn/P5046.cpp" rel="noopener" class="external-link" href="https://github.com/coder114514/OI_code/blob/main/www.luogu.com.cn/P5046.cpp" target="_blank">代码</a>:<br>#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long ll;

namespace io {
    const int SIZE = (1 &lt;&lt; 21) + 1;
    char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;
    // getchar
    #define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
    // print the remaining part
    inline void flush () {
        fwrite (obuf, 1, oS - obuf, stdout);
        oS = obuf;
    }
    // putchar
    inline void putc (char x) {
        *oS ++ = x;
        if (oS == oT) flush ();
    }
    // input a signed integer
    template &lt;class I&gt;
    inline void gi (I &amp;x) {
        for (f = 1, c = gc(); c &lt; '0' || c &gt; '9'; c = gc()) if (c == '-') f = -1;
        for (x = 0; c &lt;= '9' &amp;&amp; c &gt;= '0'; c = gc()) x = x * 10 + (c &amp; 15); x *= f;
    }
    // print a signed integer
    template &lt;class I&gt;
    inline void print (I x) {
        if (!x) putc ('0'); if (x &lt; 0) putc ('-'), x = -x;
        while (x) qu[++ qr] = x % 10 + '0',  x /= 10;
        while (qr) putc (qu[qr --]);
    }
    //no need to call flush at the end manually!
    struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
}
using io :: gi;
using io :: putc;
using io :: print;

const int N = 1e5 + 9;
const int NB = 709;

int n, m, x[N], y[N], id[N];
// pre[x]：x到它所在块块首的区间内的逆序对数量
// suf[x]: x到它所在块块尾的区间内的逆序对数量
// F[i][j]: 块i到块j的这段区间内的逆序对数量
// f[i][j]: a1-aj与第i块中的数形成的逆序对数量
int pre[N], suf[N], f[NB][N];
ll F[NB][NB], ans;
// 分块
int bel[N], L[NB], R[NB], bSize;
///////////////////////BIT
int bit[N];

inline void add(int p, int d) {
    for (int i = p; i &lt;= n; i += i &amp; -i)
        bit[i] += d;
}

inline int psq(int p) {
    int sum = 0;
    for (int i = p; i &gt; 0; i -= i &amp; -i)
        sum += bit[i];
    return sum;
}
////////////////////////////
int a[N], b[N], la, lb;
inline int merge(int *a, int *b, int la, int lb) {
    int ia = 1, ib = 1;
    int res = 0;
    while (ia &lt;= la &amp;&amp; ib &lt;= lb) {
        if (a[ia] &lt; b[ib])
            ++ia;
        else
            res += la - ia + 1, ++ib;
    }
    return res;
}
////////////////////////////
inline void init() {
    /////////分块
    bSize = 370;
    for (int i = 1; i &lt;= n; i++)
        bel[i] = (i - 1) / bSize + 1;
    for (int i = 1; i &lt;= bel[n]; i++) {
        L[i] = R[i - 1] + 1;
        R[i] = i * bSize;
    }
    R[bel[n]] = n;
    ////////算pre和suf,块内排序
    for (int i = 1; i &lt;= bel[n]; i++) {
        sort(y + L[i], y + R[i] + 1);
        int nrp = 0;
        for (int j = L[i]; j &lt;= R[i]; j++) {
            add(x[j], 1);
            nrp += j - L[i] + 1 - psq(x[j]);
            pre[j] = nrp;
        }
        F[i][i] = nrp;
        for (int j = L[i]; j &lt;= R[i]; j++) {
            suf[j] = nrp;
            add(x[j], -1);
            nrp -= psq(x[j] - 1);
        }
    }
    /////////////计算f
    for (int i = 1; i &lt;= bel[n]; i++) {
        int k = L[i];
        for (int j = 1; j &lt;= n; j++) {
            while (k &lt;= R[i] &amp;&amp; y[k] &lt; j) ++k;
            if (id[j] &lt; L[i]) {
                f[i][id[j]] = k - L[i];
            }
            else if (id[j] &gt; R[i]) {
                f[i][id[j]] = R[i] - k + 1;
            }
        }
        for (int j = 1; j &lt;= n; j++) {
            f[i][j] += f[i][j-1];
        }
    }
    /////////////计算F
    for (int k = 1; k &lt; bel[n]; k++) {
        for (int i = 1; i + k &lt;= bel[n]; i++) {
            const int j = i + k;
            F[i][j] = F[i+1][j] + F[i][j-1] - F[i+1][j-1] + f[j][R[i]] - f[j][L[i]-1];
        }
    }
}
/////////////////////
inline void solve(int l, int r) {
    int bL = bel[l], bR = bel[r];
    if (bL == bR) {
        la = lb = 0;
        for (int i = L[bL]; i &lt;= R[bL]; i++) {
            if (id[y[i]] &gt;= l &amp;&amp; id[y[i]] &lt;= r)
                b[++lb] = y[i];
            else if (id[y[i]] &lt; l)
                a[++la] = y[i];
        }
        ans = pre[r] - (l == L[bL] ? 0 : pre[l-1]) - merge(a, b, la, lb);
    }
    else {
        ans = F[bL+1][bR-1] + pre[r] + suf[l];
        for (int i = bL + 1; i &lt;= bR - 1; i++) {
            ans += f[i][R[bL]] - f[i][l-1] + f[i][r] - f[i][L[bR]-1];
        }
        la = lb = 0;
        for (int i = L[bL]; i &lt;= R[bL]; i++) {
            if (id[y[i]] &gt;= l)
                a[++la] = y[i];
        }
        for (int i = L[bR]; i &lt;= R[bR]; i++) {
            if (id[y[i]] &lt;= r)
                b[++lb] = y[i];
        }
        ans += merge(a, b, la, lb);
    }
    print(ans);
    putc('\n');
}

int main() {
    gi(n);
    gi(m);
    for (int i = 1; i &lt;= n; i++) {
        gi(y[i]);
        x[i] = y[i];
        id[x[i]] = i;
    }
    init();
    for (int i = 1; i &lt;= m; i++) {
        ll l, r;
        ll in1, in2;
        gi(in1); gi(in2);
        l = in1 ^ ans;
        r = in2 ^ ans;
        solve(l, r);
    }
    return 0;
}
Copy]]></description><link>blog\2023-02-23-毒瘤题,纪念一下.html</link><guid isPermaLink="false">blog/2023-02-23-毒瘤题,纪念一下.md</guid><pubDate>Thu, 17 Aug 2023 03:58:11 GMT</pubDate></item><item><title><![CDATA[2023-03-04-快读模版]]></title><description><![CDATA[ 
 <br>// orz laofudasuan
// modified

namespace io {
    const int SIZE = (1 &lt;&lt; 21) + 1;
    char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;
    // getchar
    #define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
    // print the remaining part
    inline void flush () {
        fwrite (obuf, 1, oS - obuf, stdout);
        oS = obuf;
    }
    // putchar
    inline void putc (char x) {
        *oS ++ = x;
        if (oS == oT) flush ();
    }
    // input a signed integer
    template &lt;class I&gt;
    inline void gi (I &amp;x) {
        for (f = 1, c = gc(); c &lt; '0' || c &gt; '9'; c = gc()) if (c == '-') f = -1;
        for (x = 0; c &lt;= '9' &amp;&amp; c &gt;= '0'; c = gc()) x = x * 10 + (c &amp; 15); x *= f;
    }
    // print a signed integer
    template &lt;class I&gt;
    inline void print (I x) {
        if (!x) putc ('0'); if (x &lt; 0) putc ('-'), x = -x;
        while (x) qu[++ qr] = x % 10 + '0',  x /= 10;
        while (qr) putc (qu[qr --]);
    }
    //no need to call flush at the end manually!
    struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
}
using io :: gi;
using io :: putc;
using io :: print;
Copy]]></description><link>blog\2023-03-04-快读模版.html</link><guid isPermaLink="false">blog/2023-03-04-快读模版.md</guid><pubDate>Thu, 17 Aug 2023 03:58:19 GMT</pubDate></item><item><title><![CDATA[2023-03-10-VSCode配置]]></title><description><![CDATA[ 
 <br><br>
<br>Material Icon Theme
<br>Competitive Programming Helper (cph)
<br>TabOut
<br>C/C++
<br>Code Runner
<br>Error Lens
<br>配置文件：<br>
<br><a rel="noopener" class="external-link" href="https://gist.github.com/coder114514/17ae32f754658e2e5a25584cb5877eeb" target="_blank">https://gist.github.com/coder114514/17ae32f754658e2e5a25584cb5877eeb</a>
<br><a rel="noopener" class="external-link" href="https://gist.github.com/coder114514/6f941aaa7e2f4706b7820ba28f656d4c" target="_blank">https://gist.github.com/coder114514/6f941aaa7e2f4706b7820ba28f656d4c</a>
]]></description><link>blog\2023-03-10-vscode配置.html</link><guid isPermaLink="false">blog/2023-03-10-VSCode配置.md</guid><pubDate>Thu, 17 Aug 2023 03:59:03 GMT</pubDate></item><item><title><![CDATA[2023-03-15-1维DP四边形不等式优化(决策单调性优化)]]></title><description><![CDATA[ 
 <br>对序列切割问题，令 ，即  到  的最优解<br> 其中  表示  到  作为一段的代价<br>若对所有  有  (四边形不等式)，即可使用此优化 (所以叫四边形不等式优化)<br>这是因为若四边形不等式满足，则<br><br>于是如果 <br>那对于所有  有  (*)<br>(*)就是强化版决策单调性<br>令  表示  的决策<br>那么  不降就是普通的决策单调性(**)，它可以由(*)得出<br>用  合并  数组中一段相同的值，并用队列维护 <br> 求出后就从右到左看它能更新哪些 ，如果能整个更新，就把这块丢掉，否则就在第一个不能整块更新的块里二分，正确性由(*)和(**)保证<br>
struct Info {
    int l, r, pre;
} q[N];

struct Opt {
    ll val, pre;
} f[N];

ll F(int j, int i) {
    // 具体问题具体分析
}

int search(Info x, int i) {
    int l = x.l;
    int r = x.r;
    int ans = r + 1;
    while (l &lt;= r) {
        int mid = (l + r) / 2;
        if (F(i, mid) &lt;= F(x.pre, mid)) {
            ans = mid;
            r = mid - 1;
        }
        else {
            l = mid + 1;
        }
    }
    return ans;
}

void DP() {
    q[1] = (Info){1, n, 0};
    int l = 1, r = 2;
    for (int i = 1; i &lt;= n; i++) {
        while (q[l].r &lt; i) l++;
        int j = q[l].pre;
        f[i] = (Opt){F(j, i), j};
        q[l].l = i + 1;
        if (q[l].r == i) l++;
        while (l &lt; r &amp;&amp; F(i, q[r-1].l) &lt;= F(q[r-1].pre, q[r-1].l)) r--;
        int pos = i + 1;
        if (l &lt; r) {
            pos = search(q[r-1], i);
            q[r-1].r = pos - 1;
        }
        if (pos &gt; n) continue;
        q[r++] = (Info){pos, n, i};
    }
    printf("%lld\n", f[n].val);
}
Copy]]></description><link>blog\2023-03-15-1维dp四边形不等式优化(决策单调性优化).html</link><guid isPermaLink="false">blog/2023-03-15-1维DP四边形不等式优化(决策单调性优化).md</guid><pubDate>Thu, 17 Aug 2023 03:59:08 GMT</pubDate></item><item><title><![CDATA[2023-03-25-2维DP四边形不等式优化(决策单调性优化)]]></title><description><![CDATA[ 
 <br>对于区间DP问题，都可以列出转移方程：<br>
<br>其中<br><br>令  表示使  最优的 <br>如果  满足：<br>
<br>区间包含单调性： 对于所有 
<br>四边形不等式： 对于所有 
<br>那么对于所有  有 <br>这样在枚举决策就只用枚举  到  了<br>当然，要注意边界情况，即  和 <br>显然这会让复杂度从  降低到 （均摊枚举决策的循环）<br><a data-tooltip-position="top" aria-label="https://dl.acm.org/doi/pdf/10.1145/800141.804691" rel="noopener" class="external-link" href="https://dl.acm.org/doi/pdf/10.1145/800141.804691" target="_blank">证明在这篇论文里</a>（这个优化英文叫 Knuth-Yao quadruple inequality speed-up）<br>就算与也有关，只要它的前两个参数满足上面两个条件，优化还是能用，<a data-tooltip-position="top" aria-label="https://cse.hkust.edu.hk/mjg_lib/bibs/DPSu/DPSu.Files/sdarticle_287.pdf" rel="noopener" class="external-link" href="https://cse.hkust.edu.hk/mjg_lib/bibs/DPSu/DPSu.Files/sdarticle_287.pdf" target="_blank">证明在这篇论文里</a><br>
struct Opt {
    int v, k;
} f[N][N];

int F(int i, int j, int k);

void DP() {
    for (int i = 1; i &lt;= n; i++) {
        f[i][i] = (Opt){0, -1};
        for (int j = i + 1; j &lt;= n; j++) {
            f[i][j] = (Opt){1 &lt;&lt; 30, -1};
        }
    }
    for (int i = 1; i &lt; n; i++) {
        f[i][i+1] = (Opt){F(i, i+1, i), i};
    }
    for (int len = 3; len &lt;= n; len++) {
        for (int i = 1, j = len; j &lt;= n; i++, j++) {
            int kl = f[i][j - 1].k;
            int kr = f[i + 1][j].k;
            for (int k = kl; k &lt;= kr; k++) {
                int v = F(i, j, k);
                if (v &lt;= f[i][j].v) {
                    f[i][j] = (Opt){v, k};
                }
            }
        }
    }
    printf("%d\n", f[1][n].v);
}
Copy]]></description><link>blog\2023-03-25-2维dp四边形不等式优化(决策单调性优化).html</link><guid isPermaLink="false">blog/2023-03-25-2维DP四边形不等式优化(决策单调性优化).md</guid><pubDate>Thu, 17 Aug 2023 03:58:26 GMT</pubDate></item><item><title><![CDATA[2023-03-26-两道有意思的微积分题目]]></title><description><![CDATA[ 
 <br><br><img alt="1.jpeg" src="\lib\media\1.jpeg"><br>相当于在近似在到的曲线下方面积, 所以结果是 <br><br><img alt="2.jpeg" src="\lib\media\2.jpeg"><br>]]></description><link>blog\2023-03-26-两道有意思的微积分题目.html</link><guid isPermaLink="false">blog/2023-03-26-两道有意思的微积分题目.md</guid><pubDate>Thu, 17 Aug 2023 03:58:33 GMT</pubDate><enclosure url="lib\media\1.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1.jpeg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2023-04-14-wqs二分]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://pufanyi.github.io/%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8/Train2012-sol-wqs.pdf" rel="noopener" class="external-link" href="https://pufanyi.github.io/%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8/Train2012-sol-wqs.pdf" target="_blank">原始论文</a><br><br>我们有时候需要解决在一定限制下的最优化问题，通常它们可以写成如下形式：在  的情况下使  最小化（最大化）。<br>但是很多时候这样的问题难以直接解决，而相应的没有限制的问题通常会更容易解决（即求  的最小值）。<br>所以如果能从无限制问题中的结果得到有限制问题的结果，我们就能更容易地解决原问题。<br><br>对于问题 ：使  最小化，其中 <br>考虑无限制问题 ：使  最小化，其中 。<br>若  有满足  的解 ，那  也是原问题  的一个解。<br>该定理可以用反证法简单地证明。<br>由上述定理可以看到，如果  关于  有单调性，就可以通过二分  和解决 （比  简单）来找到答案<br>如果问题  关于不同的限制  具有凸性（a.k.a. ）那么  关于  就有单调性<br>一般来说，凸性可以通过暴力算法打印数据找规律猜蒙凑得出<br><br><a data-tooltip-position="top" aria-label="https://www.luogu.com.cn/problem/P2619" rel="noopener" class="external-link" href="https://www.luogu.com.cn/problem/P2619" target="_blank">最小黑白生成树</a>]]></description><link>blog\2023-04-14-wqs二分.html</link><guid isPermaLink="false">blog/2023-04-14-wqs二分.md</guid><pubDate>Thu, 17 Aug 2023 03:58:47 GMT</pubDate></item><item><title><![CDATA[2023-04-17-Dev-C++翻新]]></title><description><![CDATA[ 
 <br>Dev C++ 是一个很常用的 C++ IDE，但是它的年代有点太老了，所以它现在用它可能有一些问题，所以我们需要翻新它。<br>这里的 Dev C++ 是 Bloodshed Dev C++ 5.11<br><br><a rel="noopener" class="external-link" href="https://www.zhihu.com/question/267249434/answer/2246716057" target="_blank">https://www.zhihu.com/question/267249434/answer/2246716057</a><br><br>Dev C++ 的 AStyle 是用来格式化代码的一个程序 (ctrl+shift+A调用)，但是由于它会在DevCpp\AStyle下创建临时文件，而Program Files (x86) 下的文件夹有权限问题，所以它无法正常工作（调用之后没有效果）<br>要解决这个问题，一个方法就是设置 Dev C++ 每次都按管理员身份启动（右键dev c++快捷方式 - 属性 - 兼容性 - 以管理员身份运行此程序 打勾），但是这样每次都会弹出 UAC 窗口，很麻烦<br>另一个解决办法就是用目录联接（快捷方式不行）把 Astyle 放到一个没有权限问题的地方。具体做法：先把AStyle文件夹剪切到 D:\ 然后在 DevCpp 文件夹中以管理员身份启动命令行，输入 mklink /J AStyle D:\AStyle 即可<br><br><a rel="noopener" class="external-link" href="https://www.luogu.com.cn/blog/sky-fox/jiang-dev-c-bian-ji-qi-da-zao-cheng-shen-ji-ide-ji-mei-hua" target="_blank">https://www.luogu.com.cn/blog/sky-fox/jiang-dev-c-bian-ji-qi-da-zao-cheng-shen-ji-ide-ji-mei-hua</a>]]></description><link>blog\2023-04-17-dev-c++翻新.html</link><guid isPermaLink="false">blog/2023-04-17-Dev-C++翻新.md</guid><pubDate>Thu, 17 Aug 2023 03:58:36 GMT</pubDate></item><item><title><![CDATA[2023-05-12-集合DP]]></title><description><![CDATA[ 
 <br>我们想要知道的是：对于某个集合,  (子集dp) 或者  (超集dp)，表示集合的某个性质<br>这里的加法也可以换成 min,max<br>求加法的相应dp叫做 SOS(sum on supersets/subsets) dp，求min,max的相应dp叫做 MOS(min/max on supersets/subsets) dp<br>这里以 SOS dp 为例子，我们通过二进制表示集合，这样就可以把每个集合映射到一个整数了<br>令  为msk改变后p位能形成的msk子集/超集的结果<br>子集dp:<br><br>超集dp:<br><br>可以看到，子集dp和超集dp的转移方程基本是一样的，除了条件要反一下<br>外层循环枚举，内层循环枚举，这一维可以滚动数组优化，且两层循环的枚举顺序可以任意<br>结果就是 ]]></description><link>blog\2023-05-12-集合dp.html</link><guid isPermaLink="false">blog/2023-05-12-集合DP.md</guid><pubDate>Thu, 17 Aug 2023 03:58:39 GMT</pubDate></item><item><title><![CDATA[2023-06-25-最小费用最大流]]></title><description><![CDATA[ 
 <br>一个重要的定理(Negative Cycle Optimality Conditions)：一个流的费用是最小的(在大小相同的流之中)，当且仅当它对应的残量网络中不存在负环。<br>正方向是显然的，反方向不好证明，本文暂时略过。<br>由这个定理，我们可以得到负环消去算法：先找到一个最大流，然后不停地找负环，沿负环增广，直到没有负环为止。<br>但是更常见的算法是 SSP (Successive Shortest Path) 算法，也就是把EK算法中的bfs换成SPFA。要证明这个算法的正确性，我们需要证明算法过程中不会产生负环。<br>欲证明：如果一个残量图中没有负环，那么经过一条最短路增广之后不会产生负环<br>证明：<br>使用反证法。<br>假设沿最短路增广后产生了一个负环，由于原先没有负环，必定与的反向路径有一个非空交集。因为是负环，所以，于是，因为增广前后没有变化，所以在增广之前的图中存在，把中替换为，会得到一条新的路径，也可能还会出现与不相连的几个环圈，但是注意到这几个环圈肯定在增广之前就存在(因为增广前后没有变化)，而且增广前没有负环，所以一定比更短，但是这与是最短路矛盾。<br>Q.E.D]]></description><link>blog\2023-06-25-最小费用最大流.html</link><guid isPermaLink="false">blog/2023-06-25-最小费用最大流.md</guid><pubDate>Thu, 17 Aug 2023 03:58:42 GMT</pubDate></item><item><title><![CDATA[2023-07-17-不动点法求数列通项]]></title><description><![CDATA[ 
 <br>今天复习数列，碰到了这个东西。<br>假设我们有这样的一个递推式 ，那么要求它的通项公式。我们可以先求出它的不动点 ，然后在递推式两端减去不动点  这样有时候能凑出一些特殊的容易处理的结构。<br>下面是几个例子。<br><br>，其中<br>首先求不动点  显然是有解的<br>然后两式相减得 <br>于是 <br><br>，其中对于所有 ， 且 ，，<br>求不动点<br><br>我们把复数解也考虑进来，那么不动点有1个或者2个<br>式子两端减去一个不动点 <br><br>如果只有一个不动点，那么由  可得  由此，对上式两端取倒数，然后进行一定处理后能得到  形成等差数列(如果不是全为的常数列)<br>如果有两个不动点，记为 ，那么有<br><br>做商(假设不是常数列，那么两式都不为0)<br><br>于是 形成等比数列<br>其中不动点为复数的情况比较有意思，它们对应的是周期数列(证明见参考资料)<br><br><br>牛顿迭代法求 <br>首先  得 <br>式子两端各自减去两个不动点，然后再做商可得<br><br><br>
<br><a rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/104544760" target="_blank">https://zhuanlan.zhihu.com/p/104544760</a>
<br><a rel="noopener" class="external-link" href="https://www.zhihu.com/question/566595014/answer/2758066742" target="_blank">https://www.zhihu.com/question/566595014/answer/2758066742</a>
]]></description><link>blog\2023-07-17-不动点法求数列通项.html</link><guid isPermaLink="false">blog/2023-07-17-不动点法求数列通项.md</guid><pubDate>Thu, 17 Aug 2023 03:58:52 GMT</pubDate></item><item><title><![CDATA[2023-08-24-幻影坦克]]></title><description><![CDATA[ 
 <br>所谓的幻影坦克是一类图片，在预览和点开的时候显示不一样的图<br>它们是通过 PNG 格式的 Alpha 通道实现的<br>令一个像素点在亮背景下显示颜色 ，在暗背景下显示颜色 <br>
设能达成效果的颜色为 <br>可列出方程组<br><br>可得<br><br>当  三个分量都相等时方程才有解，所以幻影坦克一般都是灰度图<br>
得<br><br>可以看到，为了让值得范围保持在  内，A图偏亮，B图偏暗]]></description><link>blog\2023-08-24-幻影坦克.html</link><guid isPermaLink="false">blog/2023-08-24-幻影坦克.md</guid><pubDate>Thu, 24 Aug 2023 06:41:24 GMT</pubDate></item><item><title><![CDATA[热力学第二定律]]></title><description><![CDATA[ 
 <br><a rel="noopener" class="external-link" href="https://zhuanlan.zhihu.com/p/58523720" target="_blank">https://zhuanlan.zhihu.com/p/58523720</a><br><br>
<br>开尔文：不可能从单一热源吸收热量，使之完全变为有用的功而不产生其他影响（"单一热源"指温度均匀并且恒定不变的热源，"其他影响"是指除了从单一热源吸热，把所吸收的热全部用来做功以外的其他任何变化
<br>克劳修斯：不可能把热量从低温物体转移到高温物体而不引起其他变化<br>
”其他影响“、”其他变化“包括机器状态的变化<br>
两种表述等价：<br>
若有一个热机违反1，则将其与一个卡诺热机相连，使其对卡诺机做功逆向运行，就违反了2，故2推出1<br>
若有一个热机违反2，则使其在另一个热机运行后把能量重新运回去就违反了1，故1推出2
<br><br>任意热机效率小于等于可逆热机，等号当且仅当可逆热机<br>一个热机从  处吸收  的热量，做  的功，在  处释放  的热量<br>
将其与一个效率为  可逆热机连接（该可逆热机反向运转）<br>则运行一次  处少了  的热量， 处多了相应的热量<br>那么必须  否则违背热力学第二定律<br>若该热机不可逆，则  否则整个循环不产生任何影响，违背不可逆性<br>
若该热机可逆，则有  和  故 <br><br> 等号当且仅当在可逆循环取到<br>把一个循环分解成无数个卡诺循环和不可逆的类似循环<br>每个小循环满足  （由卡诺定理<br>全部积起来即可得证<br><br>可逆过程中，<br><br>对于一个从  到  的过程，补上一个从  到  的可逆过程形成循环<br><br><br><br>假设物质的量不变<br><br>
<br>
（ 叫做化学常数<br>
另一种形式 ]]></description><link>blog\2023-09-20-热二到克劳修斯到熵.html</link><guid isPermaLink="false">blog/2023-09-20-热二到克劳修斯到熵.md</guid><pubDate>Wed, 20 Sep 2023 12:43:29 GMT</pubDate></item><item><title><![CDATA[2023-09-20-CSP-S-2023-复赛]]></title><description><![CDATA[ 
 <br>考场上 T1, T3 做出来了<br>T2, T4 CF 上有原题<br>这里就记录一下 T2 正解<br><br><a data-tooltip-position="top" aria-label="https://codeforces.com/contest/1223/problem/F" rel="noopener" class="external-link" href="https://codeforces.com/contest/1223/problem/F" target="_blank">原题</a><br><br>令  从  开头的可消去子串的数量<br> 是使得  可消去的最小的 <br>那么  如果  存在，否则是 <br> 可以这么求（ 存在的话）：<br>
nxt[i] := i+1

while a[nxt[i]] != a[i]:

&nbsp; &nbsp; nxt[i] = nxt[nxt[i]] + 1

Copy<br>但是这么做是  的，不能拿满分<br>所以引入  表示使得  可消去且  的最小的 <br>那么就有这样的关系<br>若  和  都存在<br>当  时  否则 <br>当  时  否则 <br>原题的代码：（CCF版缩小了值域<br> 为 ， 为  表示不存在<br>#include &lt;bits/stdc++.h&gt;
using namespace std;

const int N = 3e5 + 10;

int nQ;
int n;
int a[N];
int dp[N];
map&lt;int, int&gt; nxta[N];

void input() {
    scanf("%d", &amp;n);
    for (int i = 1; i &lt;= n; i++)
        scanf("%d", &amp;a[i]);
}

void solve() {
    for (int i = n + 1; i &gt;= 1; i--) {
        nxta[i].clear();
        dp[i] = 0;
    }
    for (int i = n - 1; i &gt;= 1; i--) {
        int nxt;
        if (a[i] == a[i + 1]) {
            nxt = i + 1;
            nxta[i] = move(nxta[nxt + 1]);
            if (nxt + 1 &lt;= n) nxta[i][a[nxt + 1]] = nxt;
            dp[i] = dp[nxt + 1] + 1;
        } else {
            nxt = nxta[i + 1][a[i]] + 1;
            if (nxt != 1) {
                nxta[i] = move(nxta[nxt + 1]);
                if(nxt + 1 &lt;= n) nxta[i][a[nxt + 1]] = nxt; //***
                dp[i] = dp[nxt + 1] + 1;
            }
        }
    }

    long long ans = 0; //***
    for (int i = 1; i &lt; n; i++) {
        ans += dp[i];
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
    scanf("%d", &amp;nQ);
    for (int iQ = 1; iQ &lt;= nQ; iQ++) {
        input();
        solve();
    }
    return 0;
}
Copy<br><br>考虑一个栈 S，每次加入一个序列中的元素，如果该元素和栈顶的是相同的，那么就消掉<br>令  表示到  为止的栈,  表示  结尾的可消去子序列的数量<br>如果有  那么就说明  到  的区间是可以消去的（证明略，那么这时候 <br>接下来状态压缩，令  表示当前栈为  时以当前位置结尾的可消去子序列数量，那么每次更新就是 <br>给  做一个哈希，然后  用 map 维护<br>#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long ll;


int n;
string s;
string stk;

const ll b1=131,b2=151;
const ll mod=1e9+7;

ll p1[2000010];
ll p2[2000010];
ll h1,h2;

map&lt;pair&lt;ll,ll&gt;,int&gt; st;

ll ans;

int main(){
    cin&gt;&gt;n&gt;&gt;s;
    p1[0]=p2[0]=1;
    for(int i=1;i&lt;=n;i++){
        p1[i]=p1[i-1]*b1%mod;
        p2[i]=p2[i-1]*b2%mod;
    }
    stk='-';
    h1=(int)stk[0]*p1[0]%mod;
    h2=(int)stk[0]*p2[0]%mod;
    st[make_pair(h1,h2)]++;
    for(char c:s){
        if(c==stk.back()){
            h1-=(int)stk.back()*p1[stk.size()-1]%mod;
            h1+=mod;
            h1%=mod;
            h2-=(int)stk.back()*p2[stk.size()-1]%mod;
            h2+=mod;
            h2%=mod;
            stk.pop_back();
        }else{
            h1+=(int)c*p1[stk.size()]%mod;
            h1%=mod;
            h2+=(int)c*p2[stk.size()]%mod;
            h2%=mod;
            stk.push_back(c);
        }
        ans+=st[make_pair(h1,h2)];
        st[make_pair(h1,h2)]++;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
Copy]]></description><link>blog\2023-09-20-csp-s-2023-复赛.html</link><guid isPermaLink="false">blog/2023-09-20-CSP-S-2023-复赛.md</guid><pubDate>Fri, 17 Nov 2023 12:52:02 GMT</pubDate></item><item><title><![CDATA[2023-12-02-NOIP2023退役记]]></title><description><![CDATA[ 
 <br>前几次 <a data-href="2022-12-06-NOIP2022游寄" href="\blog\2022-12-06-noip2022游寄.html" class="internal-link" target="_self" rel="noopener">2022-12-06-NOIP2022游寄</a> <a data-href="2023-09-20-CSP-S-2023-复赛" href="\blog\2023-09-20-csp-s-2023-复赛.html" class="internal-link" target="_self" rel="noopener">2023-09-20-CSP-S-2023-复赛</a><br><br>早上起来睡得不错，不怎么困<br>
8:00 多到考场，在七宝中学，他们在修路<br>
进考场以后就是调机器等密码，拿到密码后开始干题目<br>T1 一眼大水题，半小时之后完成，过了大样例<br>T2 先写了一个暴力，然后开始考虑正解。发现经过所有的操作之后每个变量要么等于一个常量，要么和另外一个变量相等，要么和另外一个变量的逆相等，有点像 2-SAT。忘记 2-SAT 是用并查集做的了，于是给每个变量一个点，每个变量逆一个点，每个常量一个点，如果有  就建一条  到  的单向边，然后  到  也有边。发现这是个基环森林，外加每个常量是没有出边的。于是如果  能走到 ，那么这个分量就必须全是  了，再加上直接是常量  的就是答案。开心地写好一个程序，第2个样例就假了，于是就开始疯狂修改（碰到地情况包括但不限于输出错误答案，程序卡住等。中途手画了不少图，不过还是有缓慢的进展的。卡在某个样例上（具体哪个忘了，经过大量研究后发现  能走到  这个条件不对，因为可能中间反转了奇数次，所以一致性还是能满足的。目前为止知道了如果  能走到 ，则  必定在某个环上，以及找出分量遍历环的时候也需要记录走形如  到  的边的数量。经过2小时的苦干后，过了所有样例。（后来知道了并查集做多简单<br>T3 一眼不会做，T4 看最后时间不多了，且暴力感觉不好写，就直接输出了一个样例。<br><br>看其他人游记，开始担心自己做的 T1 T2 是不是有问题，感觉这次又要寄了<br>后来出成绩了，100+100+0+0=200，还算不错，算是一个好结局吧。<br><br>T2 调代码时间用得太多了，T4 其实也不是很难，如果多花点时间，应该还是能干不少分的。]]></description><link>blog\2023-12-02-noip2023退役记.html</link><guid isPermaLink="false">blog/2023-12-02-NOIP2023退役记.md</guid><pubDate>Sat, 02 Dec 2023 15:33:15 GMT</pubDate></item></channel></rss>