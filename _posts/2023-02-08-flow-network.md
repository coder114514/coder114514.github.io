---
title: 关于网络流
layout: posts
tags: OI notes
---

这篇文章会不定期更新。

这篇文章的目的在于记录对网络流直观的理解，而不在乎它形式化的严格定义和对定理的严格验证。

oi-wiki上有更详细的讲解。

## 什么是网络流

1. 容量网络（capacity network）：一个有向图，上面每条边的权值代表这条边的容量

![容量网络](https://c2.im5i.com/2023/02/08/nXbyz.png)

2. 流量网络（flow network）：加了流量的网络，x/y表示流量/容量

![流量网络](https://c2.im5i.com/2023/02/08/nXu76.png)

![一个流](https://c2.im5i.com/2023/02/08/nXHP8.png)

流量表示从源点到终点沿着一条路径“流过了多少东西”，它不能超过每条边的容量，流可以叠加，所有流加起来就是总流量

这个定义和更形式化的定义（也就是满足一些性质的从边到实数的映射）是等价的，因为流的守恒性

3. 残量网络（residual network）：首先给容量图中没有反向边的边加上权值为0的反向边，然后每条边的权值减去流过它的流量，反向边加上流量就得到了残量网络（权值为0的边可以省略）

加了反向边之后，你就能做“退流”，也就是撤销之前的流

![残量网络](https://c2.im5i.com/2023/02/08/nXAbL.png)

### 最大流

最大流就是一个容量网络能容纳的最大的总流量

不停地找增广路径（然后在残量图上加上相应的流量）直到没有任何增广路径，我们就可以得到最大流

增广路径，就是指残量图上从S到T能增加流量的路径
![增广路径](https://c2.im5i.com/2023/02/08/nXLmt.png)

#### 算法：
1. Ford-Fulkerson: 每次通过dfs找一条增广路径

复杂度: $\mathcal{O}(|E||f|)$

是最简单的最大流算法，但是复杂度很差，在有些图上运行时间会和容量成正比

Ford-Fulkerson Killer（如果每次dfs运气不好都过中间那条边的话，算法就至少要找200次增广路了）:
![Ford-Fulkerson Killer](https://c2.im5i.com/2023/02/08/nXzhq.png)

2. Edmond-Karp~~动能算法~~: 每次通过bfs找一条增广路径

复杂度更好一点：$\mathcal{O}(|V||E|^2)$

这个复杂度网上的伪证比较多，oi-wiki上有一个[严格的证明](https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)

3. Dinic: ~~还没学~~

### 最小割
割就是把所有节点划分到两个集合中，然后起点和终点不在同一个集合，一般把包含起点$s$的集合叫做$S$，包含终点的集合$t$叫做$T$

割的大小就是所有$S$到$T$的边（也就是这个边的起点在$S$中，终点在$T$中）的权值的总和

割和流有一个性质：$总流量的大小=S到T的总流量-T到S的总流量$

接下来是一个很重要的定理：最大流最小割定理，即最大流等于最小割

所以我们可以用最大流的算法求最小流

### 应用
1. 二分图最大匹配
比如对于这个二分图
![二分图](https://c2.im5i.com/2023/02/08/nXpV3.png)

这么建图，然后再上面跑一遍最大流就可以得到最大匹配了（下图中每条边的边权都是1，反向边省略）
![二分图最大匹配](https://c2.im5i.com/2023/02/08/nX7Wy.png)

2. 对“二选一”类型的问题建模
比如有$n$个物品要放入集合$A$或集合$B$，第$i$个不放$A$要消耗$u_i$，不放$B$要消耗$v_i$，$i$和$j$不在一起要消耗$w_{ij}$，求最小消耗

那我们可以先建立一个超级源和超级汇，超级源到$i$的边权为$u_i$，$i$到超级汇的边权为$v_i$，$i$和$j$连权值为$w_{ij}$的双向边，在这张图上跑最小割，就可以得到最小消耗

可以用$+\infty$表示$i$和$j$必须放在一起