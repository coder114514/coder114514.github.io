---
title: 网络流
layout: posts
tags: OI notes
---

## 什么是网络流

首先，网络（flow network）是指一个有向图$G=(V,E)$，其中有两个特殊点源点（source）$s \in V$ 和汇点（sink）$t \in V$，（$s \neq t$）

### 容量网络（capacity network）：一个有向图，上面每条边的权值代表这条边的容量

容量$c$是一个$V \times V -> R$的映射

如果$(u,v)\in E$那么$c(u,v)$等于这条边的权值

否则$c(u,v)=0$

![容量网络](https://c2.im5i.com/2023/02/08/nXbyz.png)

### 流量网络（flow network）：加了流量的网络，x/y表示流量/容量

![流量网络](https://c2.im5i.com/2023/02/08/nXu76.png)

流量$f$也是$V \times V -> R$的映射

它要满足如下三个性质：
1. 容量限制：对于所有$(u,v)\in E$，$f(u,v) \le c(u,v)$
2. 斜对称性（skew symmetry）：$f(u,v)=-f(v,u)$
3. 流守恒性：流入一个点的流量等于流出这个点的流量，即对于所有$u \in V-\\{s,t\\}$，$\sum\limits_{(v,u) \in E}{f(v,u)}=\sum\limits_{(u,v) \in E}{f(u,v)}$

流的大小是 $v(f)=\sum\limits_{(s,v)\in E}{f(s,v)}$

### 残量网络（residual network）：$G$中所有结点和剩余容量大于 $0$ 的边构成的子图，一般记作 $G_f$

即 $G_f=(V,E_f)$，其中 $E_f=\{(u,v)|c_f(u,v)>0\}$，$c_f(u,v)$是剩余流量（Residual Capacity），$c_f(u,v)=c(u,v)-f(u,v)$

（请忽略下图中为0的边）

![残量网络](https://c2.im5i.com/2023/02/08/nXAbL.png)

## 最大流

最大流就是大小最大的流

不停地找增广路径（然后在残量图上加上相应的流量）直到没有任何增广路径，我们就可以得到最大流

增广路径就是残量网络上从源点到汇点的一条路径

![增广路径](https://c2.im5i.com/2023/02/08/nXLmt.png)

### 算法：
#### Ford-Fulkerson: 每次通过dfs找一条增广路径

复杂度: $\mathcal{O}(|E||f|)$

是最简单的最大流算法，但是复杂度很差，在有些图上运行时间会和容量成正比

Ford-Fulkerson Killer（如果每次dfs运气不好都过中间那条边的话，算法就至少要找200次增广路了）:
![Ford-Fulkerson Killer](https://c2.im5i.com/2023/02/08/nXzhq.png)

#### Edmond-Karp~~动能算法~~: 每次通过bfs找一条增广路径

找到的增广路径叫做最短步数增广路(SAP, Shortest Augmenting Path)

复杂度更好一点：$\mathcal{O}(|V||E|^2)$

实际效果: 1秒可以处理上万个节点的稀疏图

这个复杂度网上的伪证比较多，oi-wiki上有一个[严格的证明](https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)

#### Dinic: bfs+dfs每次尝试寻找多条增广路径

复杂度：$\mathcal{O}(|V|^2|E|)$

实际效果: 1秒可以处理上万个节点的稀疏图，复杂度往往比上面的好，所以不能通过将$V$$E$代入$|V|^2|E|$来估计算法复杂度

<待更新>

## 最小割
割就是把所有节点划分到两个集合中，然后起点和终点不在同一个集合，一般把包含起点$s$的集合叫做$S$，包含终点的集合$t$叫做$T$

割的大小$v(S,T)$就是所有$S$到$T$的边（也就是这个边的起点在$S$中，终点在$T$中）的权值的总和

对于任意的割$(S,T)$和流$f$，$v(f)=S到T的总流量-T到S的总流量$

证明：$v(f)=\sum\limits_{u \in S}{(\sum\limits_{(u,v) \in E}{f(u,v)}-\sum\limits_{(v,u) \in E}{f(v,u)})}$ 然后考虑每条边的贡献就可以得证

接下来是一个很重要的定理：最大流最小割定理，即最大流等于最小割

证明：由上面的性质容易得到对任意的流和割，$v(f) \le v(S,T)$ 所以如果存在一个流和一个割满足 $v(f) = v(S,T)$ 就可以证明该定理

假设我们找到了最大流，那残量网络中肯定没有从$s$到$t$的路径，于是我们可以把点划分为$s$可达$S$和$s$不可达的$T$，于是我们就得到了一个割。

那么肯定没有$T$到$S$的边，因为$T$中的点是从$s$不可达的。

从$S$到$T$一定是满流，否则残量网络中有$S$到$T$的边，但$T$应该是不可达的。

由此可以看到最大流的大小等于这个割的大小，于是最大流等于最小割

所以我们可以用最大流的算法求最小割

## 应用
1. 二分图最大匹配

比如对于这个二分图
![二分图](https://c2.im5i.com/2023/02/08/nXpV3.png)

这么建图，然后再上面跑一遍最大流就可以得到最大匹配了（下图中每条边的边权都是1，反向边省略）
![二分图最大匹配](https://c2.im5i.com/2023/02/08/nX7Wy.png)

2. 对“二选一”类型的问题建模

比如有$n$个物品要放入集合$A$或集合$B$，第$i$个不放$A$要消耗$u_i$，不放$B$要消耗$v_i$，$i$和$j$不在一起要消耗$w_{ij}$，求最小消耗

那我们可以先建立一个超级源和超级汇，超级源到$i$的边权为$u_i$，$i$到超级汇的边权为$v_i$，$i$和$j$连权值为$w_{ij}$的双向边，在这张图上跑最小割，就可以得到最小消耗

可以用$+\infty$表示$i$和$j$必须放在一起

### 例题
#### 第一题
幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。

对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。

虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。

我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。 

我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？

#### 解法
这个问题很符合上面“二选一”的模型

我们可以从超级源向每个要睡觉的小朋友连一条权值为1的边，从超级汇向每个不要睡觉的小朋友连一条权值为1的边，好朋友之间连一条权值为1的双向边，再跑最小割就能得到答案了。

#### 第二题
在一个n*n的方格里，每个格子里都有一个正整数。

从中取出若干数，使得任意两个取出的数所在格子没有公共边，且取出的数的总和尽量大。

#### 解法
因为最大总和等于所有数的和减掉最小的不选的总和

所以我们考虑如何用最小割建模最小的不选的总和

首先把格子按行号与列号的和的奇偶性分类

![](https://c2.im5i.com/2023/02/09/nYeg3.png)

从源点向偶格子连边，权值为格子中的值；从奇格子向汇点连边，权值为格子中的值；从偶格子向它周围的四个奇格子连边，权值为$+\infty$

![](https://c2.im5i.com/2023/02/09/nYaCR.md.png)

考虑一个割$(S,T)$

对于一个奇格子，在$S$里是选它，在$T$里是不选它；对于偶格子，在$S$里是不选，在$T$里是选。

如果一个奇格子是$S$，它连着的偶格子都是$S$，就代表不选偶格子（偶格子不能是$T$，因为奇格子都偶格子连了个无限大的边，如果是$T$那这个割就不可能是最小割了）

奇格子是$T$，偶格子也是$T$，就代表不选奇格子

奇格子是$T$，偶格子是$S$，就代表都不选

求出最小割，就是最小的不选的总和了

这里的这个最小割构造不是很自然，所以特别记录一下。