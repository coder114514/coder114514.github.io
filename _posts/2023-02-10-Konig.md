---
title: Konig定理和匈牙利算法

tags: OI笔记
last_modified_at: 2023/02/10
---

### Konig定理

最小点覆盖就是指用与点相连的边覆盖整个图的所有边，最少需要几个点

Konig定理：在一个二分图中，最大匹配数等于最小点覆盖

##### 证明：

首先，因为每条匹配边没有公共的端点，而一个点覆盖中它们都要被覆盖到，所以最小点覆盖肯定不小于最大匹配

接下来我们只要能构造出一个等于最大匹配数的最小点覆盖就可以证明Konig定理

在最大匹配中，一条边有四种情况：
1. 它是匹配边
2. 它两端参与两个匹配
3. 它恰好左端参与一个匹配（因为是二分图，所以我们能区分出左端右端）
4. 它恰好右端参与一个匹配

接下来我们这么选点：
1. 对于恰好左端参与一个匹配的边，选取它的左端点
2. 把端点被选中的边去掉，重复1
3. 最后对于还没选过端点的匹配边选它们的右端点

首先，选的点都是每条匹配边的一个端点，所以选出来了最大匹配数个点，也是因为这个，所有匹配边肯定被覆盖，我们只需考虑所有非匹配边

重复过1之后，第三种边已被覆盖。在最后一步之后，就能把第二种和第四种覆盖，于是所有边都被覆盖了，选出来的点确实组成了最小点覆盖。

Q.E.D

### 匈牙利算法

简单来说就是不停找交错增广路（一条路径上的边是未匹配、匹配、未匹配这样交错下去的，其中起点和终点都没有参与匹配）

![交错增广路](https://c.1ovv.com/2023/03/20/noVYW.png)

找到之后反转一下（也就是变成匹配、未匹配、匹配这样交错下去）就能使匹配数+1

![反转](https://c.1ovv.com/2023/03/20/nod7G.png)

没有交错增广路之后就得到了最大匹配

##### 代码
```cpp
bool vst[NV]; //表示右侧的点在这轮寻找交错增广路的时候有没有被访问过
int match[NV]; //表示右侧的点匹配上了左侧的哪个点

//返回值代表有没有找到交错增广路
bool find(int u) {
    for (int i = hd[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (vst[v]) continue;
        vst[v] = true;
        if (!match[v] || find(match[v])) {
            match[v] = u;
            return true;
        }
    }
    return false;
}

int Hungarian() {
    int maxMatch = 0;
    for (int u = 1; u <= nV; u++) {
        memset(vst, 0, sizeof(vst));
        maxMatch += find(u);
    }
    return maxMatch;
}
```
